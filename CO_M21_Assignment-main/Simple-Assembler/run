#!/bin/bash

# Add command to run your program here
f = open("input.txt", "r+")
l = f.readlines()
opcode = {"add": ("00000", "RRR"), "sub": ("00001", 'RRR'), "mov": ("00010", 'R$', "00011", 'RR'),
          "ld": ("00100", "Rm"), "st": ("00101", "Rm"), "mul": ("00110", "RRR"), "div": ("00111", "RR"),
          "rs": ("01000", "R$"), "ls": ("01001", "R$"), "xor": ("01010", "RRR"), "or": ("01011", "RRR"),
          "and": ("01100", "RRR"), "not": ("01101", "RR"), "cmp": ("01110", "RR"), "jmp": ("01111", "m"),
          "jlt": ("10000", "m"), "jgt": ("10001", "m"), "je": ("10010", "m"), "hlt": ("10011", "F")}
registers = {"R0": "000", "R1": "001", "R2": "010", "R3": "011", "R4": "100", "R5": "101", "R6": "110", "FLAGS": "111"}
var_dict = {}  # Stores the variable name with the memory address allocated to the variable and label
instruction_count = 0
l2 = []

def _8bit(n):         #Function to convert a binary number to 8 bit binary number
    x = bin(n)[2:]
    num = 8 - len(x)
    return "0" * num + x

for i in l:                             # Gives final list of instructions without empty lines
    if i != '''\n''':
        l2.append(i)
        if(i.strip().split()[0] in opcode): #Count of the total number of instructions excluding var and label declerations
          instruction_count+=1
    
      
for i in l2:
  tempvar=i.strip().split()
  if(tempvar[0]=="var"):          #identifying a variable decleration
    if(tempvar[1] not in var_dict):
      var_dict[tempvar[1]]=_8bit(instruction_count)
      instruction_count+=1
    else:
      print("Variable already exists")
  elif(tempvar[0][-1]==":"):      #identifying a label decleration
    if(tempvar[0][:-1] not in var_dict):
      var_dict[tempvar[0][:-1]]=_8bit(instruction_count)
      instruction_count+=1
for i in l2:
  instruction_list = i.strip().split()
  binary_instruction = ""
  #getting opcode
  if instruction_list[0] in opcode.keys():
    if instruction_list[0] != "mov":
      binary_instruction = binary_instruction + opcode[instruction_list[0]][0]
    else:
      if instruction_list[2][0] == "$":
        binary_instruction += opcode[instruction_list[0]][0]
      else:
        binary_instruction += opcode[instruction_list[0]][2]
  #getting type and values accordingly
    if instruction_list[0] != "mov":
      if opcode[instruction_list[0]][1] == "RRR": #type A
        binary_instruction = binary_instruction + "00" + registers[instruction_list[1]] + registers[instruction_list[2]] +  registers[instruction_list[3]]
        print(binary_instruction) 

      elif opcode[instruction_list[0]][1] == "R$": #type B
        if 0<= int(instruction_list[2][2:]) >=255:
          binary_instruction = binary_instruction + registers[instruction_list[1]] + _8bit(instruction_list[2])
          print(binary_instruction) 
      
      elif opcode[instruction_list[0]][1] == "RR": #type C
        binary_instruction = binary_instruction + "00000" + registers[instruction_list[1]] + registers[instruction_list[2]]
        print(binary_instruction) 

      elif opcode[instruction_list[0]][1] == "Rm": #type D
        binary_instruction = binary_instruction + registers[instruction_list[1]] + var_dict[instruction_list[2]]
        print(binary_instruction) 
    
      elif opcode[instruction_list[0]][1] == "m": #type E
        binary_instruction = binary_instruction + "000" +  var_dict[instruction_list[1]]
        print(binary_instruction) 

      elif opcode[instruction_list[0]][1] == "F": #type F
        binary_instruction = binary_instruction + "0" * 11
        print(binary_instruction)
    else:
      if instruction_list[2][0] == "$":
        binary_instruction = binary_instruction + registers[instruction_list[1]] + _8bit(int(instruction_list[2][1:])) 
        print(binary_instruction)
      else:
        binary_instruction = binary_instruction + "00000" + registers[instruction_list[1]] + registers[instruction_list[2]]
        print(binary_instruction)

   

